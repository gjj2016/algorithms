# 操作系统 #
## 磁盘调度算法 ##
假设当前磁头在67号，要求访问的磁道号顺序为98,25,63,97,56,51,55,55,6  

- **FIFO：先来先服务算法；**假设当前磁道在某一位置，依次处理服务队列里的每一个磁道，这样做的优点是处理起来比较简单，但缺点是磁头移动的距离和平均移动距离会很大。FIFO算法的服务顺序就是98,25,63,97,56,51,55,55,6 。
- **SSTF： 最短寻道时间算法；**会先处理距离当前磁道最近的磁道号，处理完成之后再处理离这个磁道号最近的磁道号，直到所有的磁道号都服务完了程序结束。性能会优于FIFO算法，但是会产生距离当前磁道较远的磁道号长期得不到服务，也就是“饥饿”现象。SSTF算法的服务顺序就是63,56,55,55,51,25,6,97,98.
- **SCAN：电梯调度算法；**先按照一个方向(比如从外向内扫描)，扫描的过程中依次访问要求服务的序列。当扫描到最里层的一个服务序列时反向扫描。SCAN算法的服务顺序就是63,56,55,55,51,25,6,97,98。
- **CSCAN： 循环扫描算法，**CSCAN算法的思想是，访问完最里面一个要求服务的序列之后，立即回到最外层欲访问磁道。也就是始终保持一个方向。CSCAN算法的服务顺序就是63,56,55,55,51,25,6,98,97。

## 内存调度算法 ##
页面置换：在地址映射过程中，若在页面中发现所要访问的页面不再内存中，则产生缺页中断(page fault)。当发生缺页中断时操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。这涉及到了虚拟内存的分配和物理内存的释放。

- **OPT：最佳替换算法；**OPT置换算法优先置换将来不会用到的页面，因此需要知道将来的事情，算法仅存在理论性。
- **FIFO：先进先出算法；**FIFO置换算法优先置换最开始调入内存中的页面
- **LRU：最近最少使用算法；**LRU置换算法优先置换最近没有使用的页面，性能最接近OPT算法。
- **Clock：时钟替换算法；**Clock算法会给每个页面一个标志位，当第一次加入内存中和命中一个页面时，标志位会置为1；当发生页面置换时，会从下往上扫描，遇到标志位为1的将标志位改为0，遇到第一个标志位为0的就换出。（注意：扫描是从上往下不中断的，下一次的扫面会从上一次的结束位置开始）

## 虚拟内存和页表 ##
- **虚拟内存和物理内存**：物理内存指的是插在主板上的内存条的大小，CPU的可寻址空间指的是地址总线的数量，如32位系统的寻址空间大小为4G；这个4G指的就是虚拟内存的大小，即使物理内存大小只有1M，对于32位系统来说，每个进程仍然相当于拥有4G的虚拟内存空间。


- **页和页帧**：虚拟内存空间有4G的地址空间，会以页的形式划分为多个页；内存空间有较小的地址空间，会以页帧的形式划分为多个页帧；程序中使用的都是虚拟地址，虚拟地址由虚拟页号和偏移量组成，虚拟地址会送到MMU，MMU根据页表找到虚拟页号对应的页帧号，如果这个页存在，那么通过页帧号和偏移量组成内存地址，如果这个页不存在，那么产生一个缺页中断（page fault），通过内存调度算法置换页面。


- **页表和多级页表**：页表存储着虚拟页号到页帧号之间的映射关系，同时记录着这个页是否发生了修改（发生了修改的在页面置换的时候需要将修改内容写会到磁盘），是否存在（不存在的页将触发缺页中断）等信息；每一个线程都有一个页表；对于32位系统，假设页的大小为4K，那么页表项将会有4GB/4K=1M，存储这个页表无疑是对内存空间的极大浪费，同时也是没必要的，因为每个进程几乎不可能会同时使用整个虚拟内存空间。多级页表中第一级页表只有1K大小，每一项对应4GB/1K=4MB地址空间，一级页表的每一项都对应二级页表中的1K项，在二级页表中，虚拟地址的前10位会先被取出来找到对应的一级页表，然后取出接下来的10位找到对应的二级页表，如果页面不存在那么触发缺页中断，如果存在则根据映射关系找到对应的页帧号，通过页帧号拼接虚拟地址的后12为组成物理地址。相比一级页表需要存储整个页表，多级页表中在第一级页表上，可以根据程序所在的虚拟地址空间，根据需要创建对应的第二级页表，因此节省了空间。


- TLB：快表。将虚拟地址直接映射到物理内存，而不必再访问页表。地址映射的时候会先访问TLB，如果发现了一个有效的匹配，并且要进行的操作没有违反保护位，则将该页框号直接从TLB中取出，而不必再去访问页表。当虚拟页号并不在TLB中时，就会进行正常的页面查询，接着从TLB中淘汰一个表项，然后用新找到的页表项代替之。