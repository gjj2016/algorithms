# 计算机网络的知识点 #
## TCP详解 ##
###1、 TCP重传 ###
TCP重传用于防止报文丢失，是保障TCP传输的可靠性、恢复错误的一种基本方法。

TCP的重传需要考虑：何时重传报文？如果重传时间过短，过多的报文重传，进一步加剧网路的拥塞程度；重传时间过长，降低数据传输效率，长时间占用资源。

TCP的重传方法：**1）超时重传**。发送方在发送了某个sqe的报文段后，等待了一段时间未收到该sqe报文的ACK报文，则重新发送该sqe的报文段。这里涉及到的等待一段时间就是报文的重传时间，在最开始可以设置为一个RTT时间，如果在RTT时间内没有收到ACK报文，则增加至RTTx2，以此内推，直到达到重传次数。**2）快速重传**。当接收方收到的sqe号不是自己所期望的sqe号时，会连续发送三个ACK报文，接收方收到三个连续的ACK报文后，会优先传送该sqe的报文段，其他sqe的报文段进入排队等待直到快速重传报文发送完。
>超时重传是发送方的傻等，快速重传是接收方主动告诉发送方报文丢失。

###2、 TCP流量控制  ###
TCP的流量控制指的是控制发送方的发送速率，是接收方来得及处理数据，以及提高网络利用率。

TCP流量控制的方法：**滑动窗口机制**。根据接收方的接收窗口大小控制发送方的发送速率。接收方在ACK报文中会给出自己的接收窗口大小，当接收窗口为0后，发送方会停止发送数据，等待接收方发送一个窗口大小不为0的ACK报文（注意：如果这个ACK报文丢失，则出现了双方互相等待的局面，解决方法为发送方在收到窗口为0的ACK报文后，启动持续计算器， 当持续计数器达到设定的时间后，发送方会发送一个探测报文给接收方，接收方则会重新返回ACK报文，如果窗口仍然为0，那么重新开始持续计数器，如果窗口不为0了， 那么继续传送数据。）

TCP流量控制中的若干问题：

1）. 何时传送TCP报文？如发送方只有1个字节，加上TCP报文头的20字节，再加上IP报文头的20字节，发送出去41字节仅1个字节是有效数据，可见这种传输效率不高，合适发送TCP报文成为一个问题。**Nagle算法**提出将发送端的数据缓冲到一定数量之后再发送，同时规定当数据达到发送窗口的一半或者达到最大数据长度MSS后，立即发送一个报文，这样可以有效利用网络。

2）. 糊涂窗口综合症。这种情况见与接收端的处理数据能力低，接受窗口内已经填满了数据，但是每次只能处理一个数据，然后发送一个窗口大小为1的ACK报文，然后发送方发出值包含一个数据的报文，导致效率低。**解决这个问题可以**让接收方等待一段时间再发送ACK报文，等到接收窗口能够接收一个最大报文长度或者接收窗口空闲了一半再发送ACK报文。

常见的滑动窗口协议：

1). **比特滑动窗口协议**。此时发送方和接收方的窗口大小均为1，发送一帧之后就等待确认。

2). **后退n协议**。此时发送方窗口不为1，而接收方窗口大小为1，发送连续多个数据帧，接收方对每个数据帧都发送ACK确认，如果中间的某个数据帧丢失，那么需要重传这个数据帧以及这个数据帧之后的所有数据帧，即使这个数据帧之后的那些数据帧已经正确接收了。

3）.**选择重传协议**。相比后退n协议，发送方只需要重传丢失的那个数据帧，但是接收方需要额外的缓存空间存储哪些为按序达到的数据帧。

###3、 TCP拥塞控制 ###
TCP拥塞控制是就整个网络而言的，控制的是整个网络中的数据包数量（注意与TCP流量控制区分开，流量控制是就两个点而言的，是端到端的控制方法）。如果没有拥塞控制，那么任一发送方发现有丢包现象是，就马上开始重传，这样会造成网络的更加拥塞，最终造成死锁。

TCP拥塞控制的算法：慢开始和拥塞避免、快重传和快恢复

**慢开始和拥塞避免：**其中**慢开始算法**最初将发送窗口大小设置为一个MSS大小，以MSS为单位，则是将初始发送窗口大小设置为1，每收到一个ACK报文（即经过一个RTT），就将发送窗口大小增加1，具体就是最初窗口大小为1，如果按时收到ACK报文，那么窗口大小设置为2，此时可以发送两个报文，如果按时收到ACK报文，那么窗口大小设置为4，真是产生的效果是发送窗口大小每次增加为上一次的2倍。
而 **拥塞避免算法**则是线性增加窗口大小。搭配使用 **慢开始和拥塞避免**的效果是：发送窗口大小从1开始成倍增加，如果窗口大小达到 **慢开始门限**，那么开始执行拥塞避免算法，窗口大小按线性增加，无论在慢开始阶段还是在拥塞避免阶段，只要没有按时收到ACK报文（即网络产生拥塞），那么窗口大小直接减小为1，迅速减少网络中的数据包的数量，而且 **慢开始门限**下降为之前的一半（但是不能小于2），重新开始执行慢开始算法和拥塞避免算法。

**快重传和快恢复：**其中**快重传算法**要求接收方对收到的报文必须立即发出确认，而不是等到接收方要发送数据了使用捎带确认，假设接收方收到了M2这个报文，但是没有收到M3这个报文，后续收到M4、M5、M6，均立即发出对 **M2**报文的重复确认，当发送方连续收到三个重复确认后，立即发送丢失的报文，这就是快重传。**快恢复算法**指的是发生拥塞后，将慢开始门限降为之前的一半，并连续发出三个重复确认，此时不重新开始执行慢开始算法，而是将窗口大小设置为此时的慢开始门限，然后执行拥塞避免算法线性增加窗口大小。这么做的理由是既然能够收到三个连续的重复确认，说明网络状况还可以，因此不需要将窗口大小设置的过小，这就是快恢复算法。

**实际上，以上算法的前提条件是接收方拥有足够大的接受窗口大小，但是接收窗口大小并不是足够大，因此实际的发送窗口大小应该是上述窗口大小和接收窗口大小的较小值。**

###4、 TCP的连接建立过程-三次握手 ###

-  客户端主动打开连接，发送报文SNY=1，sqe=x（SYN报文不能携带数据，但是要消耗一个序号），并进入SNY_SENT状态
-  服务器端被动打开连接，并进入LISTEN状态，收到客户端的SNY报文后，发送确认报文SNY=1，ACK=1，sqe=y，ack=x+1（SNY报文不能携带数据，但是要消耗一个序号），并进入SNY_RCVD状态。
- 客户端收到服务器端的确认报文，还需要向服务器端发送一个确认报文ACK=1，sqe=x+1，ack=y+1（ACK报文可以携带数据，携带数据将会消耗一个序号，也可以不携带数据，那将不消耗序号），发送处确认报文后，客户端进入连接建立状态，服务器端收到该确认报文后，也进入连接建立状态。

###5、 TCP的连接释放过程-四次握手 ###
- 客户端传送完数据后，发送连接关闭报文FIN=1，sqe=u（u应该等于前面最后一个数据报文的序号加1），FIN报文也不能携带数据，但是要消耗一个序号，客户端此时进入FIN-WAIT 1状态
- 服务器端收到客户端的关闭连接报文后，发送一个确认报文ACK=1，sqe=v，ack=u+1（v也应该等于服务器前面传送的最后一个数据报文的序号加1），此时TCP处于半关闭状态，即从客户端到服务器端的连接已经被关闭，客户端无法再发送数据，但是服务器端到客户端的连接仍然开启，服务器端还可以发送数据到客户端，服务器端此时进入CLOSE-WAIT状态
- 客户端收到服务器端的确认报文后，进入FIN-WAIT 2状态，此时服务器端仍然可以继续往客户端发送数据，等待服务器端的数据发送完毕后，服务器再发送一个确认报文FIN=1，ACK=1，ack=u+1，sqe=w（w也应该等于服务器端刚刚发送的最后一个数据报文的序号加1），服务器端此时进入LAST-ACK状态，等待客户端的最后一次确认
- 客户端收到服务器端的连接关闭确认报文后，发送一个确认报文ACK=1，sqe=u+1，ack=w+1，此时客户端进入TIME-WAIT状态，等待两个报文最大生存时间**（2MSL）**后关闭连接，而服务器端在收到客户端发送的最后一个确认报文后就会进入关闭状态

**客户端发送了最后一个确认报文后，必须等待2MSL才能进入关闭状态。一方面确保服务器端能够收到客户端发送的最后一个确认报文（如果服务器端没有收到客户端的最后一个确认报文，那么服务器端会超时重传关闭连接确认报文，并继续上诉连接释放过程；另一方面可以确保本次连接中产生的所有报文都失效，防止产生‘已失效的连接请求报文’。）**