# Java的内存划分、内存模型、volatile #
##  Java的内存划分 ##
Java程序运行时，JVM会将管理的内存划分为几个区域：

- 方法区：方法区是所有线程共享的，用于存放加载的类信息、静态变量、常量等。
- 堆：堆也是所有线程共享的，是对象划分的主要区域，也是垃圾回收的主要区域。
- 程序计数器：每个线程独立拥有一个程序计数器，用于指示程序的执行顺序
- 本地方法区：每个线程独立用于，主要为native方法服务
- 虚拟机栈：随着线程的创建而创建，因此是每个线程独立拥有的。虚拟机栈又叫方法执行的内存模型，每个方法对应虚拟机栈中的一个栈帧，而每个栈帧由局部变量、参数列表等信息构成。

## Java内存模型 ##
Java内存模型描述的是一组规范，这组规范规定了程序中各个变量的访问方式，更具体的说就是一个程序对应一个或者多个线程，这多个线程如何操作存储、访问各个变量。

Java内存模型规定每个线程只能操作自己的工作内存、而不能直接操作主存。线程在实际执行过程中，需要先将主存中的操作数拷贝到自己的工作内存中，在工作内存中完成操作之后再将操作数写回到主存中，当多个线程操作同一个操作数时，可能会产生线程安全问题。

**工作内存：**每个线程都有自己独立的工作内存，因此工作内存是线程独立的。理论上应该是存放程序计数器、虚拟机栈以及本地方法区的。线程操作工作内存中的数据不会产生线程安全问题。对于基本数据类型，线程的工作内存中直接将其值存放在栈帧中，如果是引用类型的变量，那么该变量的引用会存储在栈帧中，而对象会在主存中划分。

**主存：**主存是所有线程的共享空间，理论上存放的是堆和方法区。线程将操作数写回到主存时，可能由于多个线程操作了同一个操作数而产生线程安全问题。

## JMM-Java内存模型对原子性、可见性、有序性的保障 ##

- 原子性的概念：程序中的一个操作一旦开始就一定会执行完。比如线程A将变量a赋值为1，线程B将变量a赋值为2，那么变量a的值最后要么是1要么是2，不会是其他值。（32位虚拟机中long和double类型的变量的操作可能因为每次只能操作32位，存在写完32位之后，后32位被其他线程写入的情况，导致结果既不是1也不是2）
- 可见性的概念：一个线程对一个变量的修改对其他线程是可见的。在单线程环境下，可见性是保证的；在多线程环境下，由于线程的工作内存和主存之间的延迟问题可能导致对某个共享变量的修改对其他线程不可见。
- 有序性的概念：即操作是有序的。单线程环境中，虽然存在编译器重排、指令重排，但是没有改变程序语义，因此也是有序的；但是多线程环境中，则是乱序的。

**指令重排：**计算机在执行程序时，为了提高性能，在不改变程序语义的前提下，对指令重排。

- **编译器重排**：在程序的编译阶段，不改变程序语义的前提下，编译器会改变程序中代码的执行顺序。

线程 1             线程 2

 x2 = a ;       x1 = b ;

 b = 1;          a = 2 ;

程序的执行结果可能并不会出现x1=1, x2=2；但是由于线程1的两行代码之间没有数据依赖关系，线程2的两行代码之间也没有依赖关系，编译器可能会对程序代码重排：
线程 1              线程 2

 b = 1;           a = 2 ; 

x2 = a ;         x1 = b ;

多线程环境中，由于存在编译器重排，变量之间的一致性无法保证的。

- **处理器指令重排：**指令按照指令流水的方式执行，一旦某条指令出现等待，后续的指令都要等待一个或多个周期，即出现流水中断。为了避免出现流水中断，处理器会先让那些对前面数据没有依赖关系的指令执行，将对前面指令的结果有依赖关系的指令换到后面执行。

**指令重排仅仅保证单线程中语义的一致性，并不考虑多线程环境下的数据一致性问题**

为了保证原子性、可见性、有序性，除了可以使用synchronized关键字、volatile关键字、ReetrantLock重入锁之外，JMM也提供了一套规则保证这三个特性，**happens-before原则：**

- 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。

- 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前。

- volatile规则，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。

- 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见

- 传递性 A先于B ，B先于C 那么A必然先于C

- 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。

- 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。

- 对象终结规则 对象的构造函数执行，结束先于finalize()方法

**如果不满足上述规则的任何一条，也没用使用任何同步手段，那么在多项称环境下将会出现线程安全问题。**

## volatile关键字 ##
- **可见性：**使用volatile关键字修饰的变量对线程是立即可见的。

		public class VolatileVisibility {
	    	public static volatile int i =0;
	
	    	public static void increase(){
	        	i++;
	    	}
		}
这段代码试图通过volatile的可见性来保证线程安全问题，但是是错误的。因为i++需要分两步完成，第一步是取i的值，第二步是写回i的值；volatile关键字只能保证所有线程看到的i的最新值，但是如果线程A读去了i的值，在写回之前，线程B也读取了i的值，线程B读到的值与线程A读到的值时一样的，那么此时将产生线程安全问题。 此时应该使用synchronized关键字保证线程安全。

		public class VolatileSafe {
	
	    	volatile boolean close;
	
	    	public void close(){
	        	close=true;
	    	}
	
	    	public void doWork(){
	        	while (!close){
	        	    System.out.println("safe....");
	        	}
	    	}
		}

这种情形能够保证所有线程看到的close变量都是最新值，多线程环境下能够保证安全问题。
	
- **禁止指令重排：**volatile关键字通过内存屏障保证被这个关键字修饰的变量在指令顺序上禁止重排。

		public class DoubleCheckLock {
	
	    	private static DoubleCheckLock instance;
	
	    	private DoubleCheckLock(){}
	
	    	public static DoubleCheckLock getInstance(){
	
	        	//第一次检测
	        	if (instance==null){
	        	    //同步
	        	    synchronized (DoubleCheckLock.class){
	        	        if (instance == null){
	        	            //多线程环境下可能会出现问题的地方
	        	            instance = new DoubleCheckLock();
	        	        }
	        	    }
	        	}
	        	return instance;
	    	}
		}
这段双重检测单例模式，在多线程环境下由于指令重排可能会出现安全问题，instance = new DoubleCheckLock();实际是通过多条指令完成。此时需要将instance变量声明为volatile：private static volatile DoubleCheckLock instance;